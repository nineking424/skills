# Vulnerability Patterns and Detection

Common vulnerability patterns, how to detect them, and prevention strategies.

## Injection Vulnerabilities

### SQL Injection Patterns

**Pattern Detection:**
```regex
# Detect string concatenation in SQL queries
SELECT.*\+.*
SELECT.*{.*}
SELECT.*%.*
query\s*=\s*['"](SELECT|INSERT|UPDATE|DELETE).*['"].*\+
```

**Vulnerable Code Patterns:**

**Python:**
```python
# Pattern 1: F-string concatenation
query = f"SELECT * FROM users WHERE id = {user_id}"

# Pattern 2: String concatenation
query = "SELECT * FROM users WHERE name = '" + name + "'"

# Pattern 3: % formatting
query = "SELECT * FROM users WHERE email = '%s'" % email

# Pattern 4: .format()
query = "SELECT * FROM users WHERE role = {}".format(role)
```

**JavaScript:**
```javascript
// Pattern 1: Template literal
const query = `SELECT * FROM users WHERE id = ${userId}`;

// Pattern 2: String concatenation
const query = "SELECT * FROM users WHERE name = '" + name + "'";

// Pattern 3: String interpolation
const query = 'SELECT * FROM users WHERE email = "' + email + '"';
```

**Java:**
```java
// Pattern 1: String concatenation
String query = "SELECT * FROM users WHERE id = " + userId;

// Pattern 2: String.format()
String query = String.format("SELECT * FROM users WHERE name = '%s'", name);

// Pattern 3: StringBuilder
StringBuilder query = new StringBuilder();
query.append("SELECT * FROM users WHERE email = '");
query.append(email);
query.append("'");
```

### Command Injection Patterns

**Detection Regex:**
```regex
os\.system\(
subprocess\.(call|run|Popen).*shell\s*=\s*True
exec\(
eval\(
Runtime\.getRuntime\(\)\.exec\(
```

**Vulnerable Patterns:**

**Python:**
```python
# Pattern 1: os.system with user input
import os
os.system(f"ping {host}")

# Pattern 2: subprocess with shell=True
import subprocess
subprocess.run(f"cat {filename}", shell=True)

# Pattern 3: eval/exec
eval(user_code)
exec(user_code)
```

**JavaScript:**
```javascript
// Pattern 1: child_process.exec
const { exec } = require('child_process');
exec(`ping ${host}`);

// Pattern 2: eval
eval(userCode);

// Pattern 3: Function constructor
new Function(userCode)();
```

**Java:**
```java
// Pattern 1: Runtime.exec with string
Runtime.getRuntime().exec("ping " + host);

// Pattern 2: ProcessBuilder with shell
ProcessBuilder pb = new ProcessBuilder("sh", "-c", command);
```

### XSS Patterns

**Detection Patterns:**
```javascript
// Pattern 1: innerHTML with user data
element.innerHTML = userData;

// Pattern 2: document.write
document.write(userData);

// Pattern 3: eval/Function
eval(userData);

// Pattern 4: Unescaped template variables
<div>${userData}</div>  // In template literal

// Pattern 5: dangerouslySetInnerHTML (React)
<div dangerouslySetInnerHTML={{__html: userData}} />
```

**Vulnerable Code Examples:**

**JavaScript:**
```javascript
// Pattern 1: Direct DOM manipulation
document.getElementById('output').innerHTML = userInput;

// Pattern 2: jQuery html()
$('#output').html(userInput);

// Pattern 3: URL parameter in DOM
const name = new URLSearchParams(location.search).get('name');
document.getElementById('greeting').innerHTML = `Hello ${name}`;

// Pattern 4: postMessage without validation
window.addEventListener('message', (event) => {
    document.body.innerHTML = event.data;  // Dangerous
});
```

### Path Traversal Patterns

**Detection Regex:**
```regex
\.\./
\.\.\\/
%2e%2e%2f
%252e%252e%252f
```

**Vulnerable Patterns:**

**Python:**
```python
# Pattern 1: Direct path concatenation
file_path = "/var/uploads/" + filename

# Pattern 2: os.path.join without validation
import os
file_path = os.path.join(base_dir, user_provided_path)
```

**JavaScript:**
```javascript
// Pattern 1: Direct path concatenation
const filePath = `/uploads/${filename}`;

// Pattern 2: path.join without validation
const path = require('path');
const filePath = path.join(__dirname, 'uploads', userPath);
```

**Java:**
```java
// Pattern 1: File constructor with user input
File file = new File("/var/uploads/" + filename);

// Pattern 2: Path concatenation
Path filePath = Paths.get("/var/uploads/", userPath);
```

---

## Authentication & Authorization Vulnerabilities

### Missing Authorization Checks

**Detection Pattern:**
```python
# Look for data access without authorization check
# No call to check_permission, require_auth, etc.

@app.route('/admin/delete/<id>')
def delete_user(id):
    # Missing: if not current_user.is_admin: abort(403)
    User.query.filter_by(id=id).delete()
```

**Vulnerable Patterns:**

**JavaScript (Express):**
```javascript
// Pattern 1: No middleware, no checks
app.delete('/api/users/:id', (req, res) => {
    deleteUser(req.params.id);  // Anyone can delete any user
});

// Pattern 2: Only authentication, no authorization
app.delete('/api/users/:id', authenticateToken, (req, res) => {
    deleteUser(req.params.id);  // Authenticated but not authorized
});
```

**Java (Spring):**
```java
// Pattern 1: No @PreAuthorize annotation
@DeleteMapping("/api/users/{id}")
public void deleteUser(@PathVariable Long id) {
    userService.delete(id);  // Missing authorization
}

// Pattern 2: No role check
@GetMapping("/admin/data")
public Data getAdminData() {
    return adminDataService.getData();  // Missing @RolesAllowed("ADMIN")
}
```

### Insecure Session Management

**Vulnerable Patterns:**

**Python (Flask):**
```python
# Pattern 1: Predictable session ID
session['user_id'] = user.id
# Using default session secret (easily guessable)

# Pattern 2: No session regeneration after login
@app.route('/login', methods=['POST'])
def login():
    if authenticate(username, password):
        session['logged_in'] = True  # Session fixation vulnerability
```

**JavaScript:**
```javascript
// Pattern 1: JWT without expiration
const token = jwt.sign({ userId: user.id }, SECRET);

// Pattern 2: Storing sensitive data in localStorage
localStorage.setItem('token', token);  // XSS can steal
localStorage.setItem('user', JSON.stringify(userData));
```

### Weak Password Policies

**Detection Patterns:**
```python
# Look for password validation
# If length < 12 or no complexity checks, flag it

def create_user(password):
    if len(password) < 8:  # Too weak
        raise ValueError("Password too short")
    # No check for uppercase, lowercase, numbers, symbols
```

---

## Cryptographic Vulnerabilities

### Weak Hashing Algorithms

**Detection Regex:**
```regex
md5\(
sha1\(
hashlib\.md5
hashlib\.sha1
MessageDigest\.getInstance\(['"]MD5['"]\)
MessageDigest\.getInstance\(['"]SHA-1['"]\)
crypto\.createHash\(['"]md5['"]\)
```

**Vulnerable Patterns:**

**Python:**
```python
# Pattern 1: MD5 for passwords
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()

# Pattern 2: SHA1 for passwords
password_hash = hashlib.sha1(password.encode()).hexdigest()

# Pattern 3: No salt
password_hash = hashlib.sha256(password.encode()).hexdigest()
```

**JavaScript:**
```javascript
// Pattern 1: MD5
const crypto = require('crypto');
const hash = crypto.createHash('md5').update(password).digest('hex');

// Pattern 2: SHA1
const hash = crypto.createHash('sha1').update(password).digest('hex');
```

**Java:**
```java
// Pattern 1: MD5
MessageDigest md = MessageDigest.getInstance("MD5");
byte[] hash = md.digest(password.getBytes());

// Pattern 2: SHA-1
MessageDigest md = MessageDigest.getInstance("SHA-1");
```

### Hardcoded Secrets

**Detection Regex:**
```regex
password\s*=\s*['"][^'"]+['"]
api[_-]?key\s*=\s*['"][^'"]+['"]
secret\s*=\s*['"][^'"]+['"]
token\s*=\s*['"][^'"]+['"]
aws[_-]?access[_-]?key
private[_-]?key
```

**Vulnerable Patterns:**

**Python:**
```python
# Pattern 1: Hardcoded password
DATABASE_PASSWORD = "MySecretPassword123"

# Pattern 2: API key in code
API_KEY = "sk_live_abc123xyz789"

# Pattern 3: Private key
PRIVATE_KEY = "-----BEGIN RSA PRIVATE KEY-----\n..."

# Pattern 4: AWS credentials
AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
```

**JavaScript:**
```javascript
// Pattern 1: Database credentials
const dbConfig = {
    host: 'localhost',
    user: 'admin',
    password: 'hardcoded_password'  // Vulnerable
};

// Pattern 2: JWT secret
const SECRET_KEY = 'my-super-secret-key';

// Pattern 3: Third-party API keys
const STRIPE_SECRET_KEY = 'sk_test_abc123';
```

### Weak Encryption

**Vulnerable Patterns:**

**Python:**
```python
# Pattern 1: DES encryption
from Crypto.Cipher import DES
cipher = DES.new(key, DES.MODE_ECB)  # Weak algorithm and mode

# Pattern 2: ECB mode (not secure)
from Crypto.Cipher import AES
cipher = AES.new(key, AES.MODE_ECB)  # ECB reveals patterns

# Pattern 3: Static IV
iv = b'1234567890123456'  # Predictable IV
cipher = AES.new(key, AES.MODE_CBC, iv)
```

**Java:**
```java
// Pattern 1: DES
Cipher cipher = Cipher.getInstance("DES");  // Weak algorithm

// Pattern 2: ECB mode
Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");  // Insecure mode

// Pattern 3: Static key
byte[] key = "STATIC_KEY_12345".getBytes();  // Predictable
```

---

## Insecure Deserialization

### Detection Patterns

**Python:**
```python
# Pattern 1: pickle.loads with untrusted data
import pickle
data = pickle.loads(user_input)  # Can execute arbitrary code

# Pattern 2: PyYAML unsafe load
import yaml
data = yaml.load(user_input)  # Use yaml.safe_load instead
```

**JavaScript:**
```javascript
// Pattern 1: eval on JSON-like data
const data = eval('(' + userInput + ')');

// Pattern 2: Function constructor
const func = new Function('return ' + userInput);
const data = func();

// Pattern 3: vm.runInContext without sandbox
const vm = require('vm');
vm.runInContext(userCode, context);
```

**Java:**
```java
// Pattern 1: ObjectInputStream with untrusted data
ObjectInputStream ois = new ObjectInputStream(inputStream);
Object obj = ois.readObject();  // Can execute code during deserialization

// Pattern 2: XMLDecoder
XMLDecoder decoder = new XMLDecoder(inputStream);
Object obj = decoder.readObject();  // Arbitrary code execution
```

---

## Server-Side Request Forgery (SSRF)

### Detection Patterns

**Vulnerable Code:**

**Python:**
```python
# Pattern 1: User-controlled URL
import requests
url = request.args.get('url')
response = requests.get(url)  # Can access internal services

# Pattern 2: URL in parameter
def fetch_image(image_url):
    return requests.get(image_url).content
```

**JavaScript:**
```javascript
// Pattern 1: fetch with user URL
const url = req.query.url;
const response = await fetch(url);

// Pattern 2: Axios with user input
axios.get(req.body.imageUrl);
```

**Java:**
```java
// Pattern 1: URL from parameter
String url = request.getParameter("url");
URL urlObj = new URL(url);
URLConnection conn = urlObj.openConnection();

// Pattern 2: HttpClient with user URL
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create(userProvidedUrl))
    .build();
```

---

## Race Conditions

### TOCTOU (Time-of-Check-Time-of-Use)

**Vulnerable Patterns:**

**Python:**
```python
# Pattern 1: Check then use
if os.path.exists(filename):  # Check
    with open(filename, 'r') as f:  # Use - file could be replaced
        data = f.read()

# Pattern 2: Check balance then deduct
if account.balance >= amount:  # Check
    time.sleep(0.1)  # Race condition window
    account.balance -= amount  # Use
```

**Java:**
```java
// Pattern 1: Check then create
if (!file.exists()) {  // Check
    file.createNewFile();  // Use - race condition
}

// Pattern 2: Non-atomic operations
if (counter < MAX) {  // Check
    counter++;  // Use - not thread-safe
}
```

---

## Information Disclosure

### Verbose Error Messages

**Vulnerable Patterns:**

**Python:**
```python
# Pattern 1: Exposing stack trace
@app.errorhandler(Exception)
def handle_error(e):
    return str(e), 500  # Reveals implementation details

# Pattern 2: Database errors exposed
try:
    db.execute(query)
except Exception as e:
    return {"error": str(e)}, 500  # Shows SQL structure
```

**JavaScript:**
```javascript
// Pattern 1: Exposing error details
app.use((err, req, res, next) => {
    res.status(500).json({ error: err.message, stack: err.stack });
});

// Pattern 2: Detailed validation errors
if (!user) {
    return res.status(401).json({ error: 'User not found' });  // Username enumeration
}
```

### Sensitive Data in Logs

**Vulnerable Patterns:**
```python
# Pattern 1: Logging passwords
logger.info(f"User login: {username}, password: {password}")

# Pattern 2: Logging credit cards
logger.debug(f"Processing payment for card: {credit_card_number}")

# Pattern 3: Logging tokens
logger.info(f"Auth token: {token}")
```

---

## Detection Tools & Techniques

### Static Analysis Tools

**Python:**
- Bandit: Scans for common security issues
- Safety: Checks dependencies for known vulnerabilities
- Semgrep: Pattern-based security scanning

**JavaScript:**
- ESLint security plugins
- npm audit
- Snyk

**Java:**
- SpotBugs with FindSecBugs
- SonarQube
- OWASP Dependency-Check

### Code Review Checklist

1. **Input Validation**
   - [ ] All inputs validated
   - [ ] Type checking enforced
   - [ ] Length limits applied
   - [ ] Special characters sanitized

2. **SQL/NoSQL Queries**
   - [ ] Parameterized queries used
   - [ ] No string concatenation in queries
   - [ ] ORM used where possible

3. **Authentication/Authorization**
   - [ ] Authorization checks present
   - [ ] Session management secure
   - [ ] Password policies enforced

4. **Cryptography**
   - [ ] Strong algorithms used
   - [ ] No hardcoded secrets
   - [ ] Proper key management

5. **Error Handling**
   - [ ] Generic error messages
   - [ ] No sensitive data in logs
   - [ ] Errors logged securely

6. **Dependencies**
   - [ ] Dependencies up to date
   - [ ] No known vulnerabilities
   - [ ] Minimal dependencies used

---

## Summary

Common vulnerability patterns to watch for:
1. String concatenation in SQL queries
2. shell=True in subprocess calls
3. innerHTML with user data
4. Missing authorization checks
5. Hardcoded secrets in code
6. MD5/SHA1 for password hashing
7. Unvalidated user input in file paths
8. Insecure deserialization
9. User-controlled URLs in requests
10. Verbose error messages in production
